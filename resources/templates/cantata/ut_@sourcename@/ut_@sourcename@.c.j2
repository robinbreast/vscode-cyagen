/*****************************************************************************/
/*                            Cantata Test Script                            */
/*****************************************************************************/
/*
 *    Filename: ut_@sourcename@.c
 *    Generated on: @date@
 *    Generated from: @sourcename@.c
 */
/*****************************************************************************/
/* Environment Definition                                                    */
/*****************************************************************************/

#define TEST_SCRIPT_GENERATOR 2

/* Include files from software under test */
@incs@@captured@
@end-incs@// TODO: remove unnecessary inclusion like *_MemMap.h files

#include <cantpp.h> /* Cantata Directives */
#include <stdio.h>
// TODO: include necessary header files for UT script

// extra utility function for CANTATA
void LOG_SCRIPT_ERROR_FORMAT(const char *fmt, ...)
{
    #define MAX_ERROR_STRING_SZ   (512)
    char buf[MAX_ERROR_STRING_SZ + 1] = {0};
    va_list args;
    int len = 0;

    va_start(args, fmt);
    len = vsnprintf(buf, sizeof(buf) - 1, fmt, args);
    va_end(args);

    if (len < 0)
        len = 0;
    else if (len > MAX_ERROR_STRING_SZ)
        len = MAX_ERROR_STRING_SZ;

    buf[len] = '\0';
    CPPTH_LOG_SCRIPT_ERROR(buf);
}
#define LOG_SCRIPT_ERROR_EX(fmt,...) LOG_SCRIPT_ERROR_FORMAT("%s():%d:%s => "fmt, __func__,__LINE__, CPPTH_GET_CALLINST(), ##__VA_ARGS__)

/* pragma qas cantata testscript start */

// access private data
// IMPORTANT: THE ORDER OF VARIABLE LIST SHALL BE THE SAME AS TARGET SOURCE
typedef struct
{
    @static-global-vars@@dtype@ *ref_@name-expr@;
    @end-static-global-vars@
} @sourcename@_av_struct;
extern @sourcename@_av_struct av_@sourcename@;
@static-local-vars@extern char cppth_alf_@sourcename@_@func-name@_@name@(void *, char *);
extern @dtype@* cppth_alv_@sourcename@_@func-name@_@name-expr@;
@end-static-local-vars@

// to access static variables: refer to https://inside-docupedia.bosch.com/confluence/pages/viewpage.action?pageId=1876908403
// ACCESS_VARIABLE(<SourceFileName>, <StaticGlobalVariable>)
// ACCESS_LOCAL_VARIABLE(<SourceFileName>, <FunctionName>, <StaticLocalVariable>) <-- need to call the function in advance before access

// access private function
@local-fncs@extern @rtype@ ACCESS_FUNCTION_@sourcename@_@name@(@args@);
@end-local-fncs@

// local function
// TODO: local functions for test functions

/*****************************************************************************/
/* Test Cases                                                                */
/*****************************************************************************/

@fncs@void test_@name@(int doIt)
{
    if (doIt)
    {
        /* Test case data declarations */
        // TODO: fill with the corresponding RQM entry
        START_TEST("[RQMID]: UTC_[Component Name]_@sourcename@_@name@",
                   "https://rb-alm-08-p.de.bosch.com/qm/web/console/LiDAR_QM/_tBmcjtGOEeqISpkAiDF6Yw#action=com.ibm.rqm.planning.home.actionDispatcher&subAction=viewTestCase&id=[RQMID]");

        // TODO: implement test steps
        START_STEP("1_NTS: ", TRUE);
        {
            // set precondition
            // expected calls
            //EXPECT_CALL("", "1", "default");
            // call SUT
            //const @rtype@ result = @name@(@args@);
            // check results
            //CHECK_U_CHAR(result, E_OK);
            // check expected calls
            //END_CALLS();
        }
        END_STEP();

        END_TEST();
    }
}
@end-fncs@

/*****************************************************************************/
/* Call Interface Control                                                    */
/*****************************************************************************/

// Stub functions
// TODO: implement necessary stub functions
/*
Std_ReturnType stubfunc_example()
{
    REGISTER_CALL(__func__);
    IF_INSTANCE("default")
    {
        return E_OK;
    }
    LOG_SCRIPT_ERROR_EX("Call instance not defined.");
    return E_NOT_OK;
}
*/

// Wrapper functions
#pragma qas cantata ignore on
@ncls-once@// wrapper for @callee.name@
int BEFORE_@callee.name@(
    @callee.args@)
{
    REGISTER_CALL("@callee.name@");
    IF_INSTANCE("default")
    {
        return AFTER_WRAPPER;
    }
    // TODO: instances for wrapping
    #if 0
    IF_INSTANCE("E_OK")
    {
        return REPLACE_WRAPPER;
    }
    #endif
    LOG_SCRIPT_ERROR_EX("Call instance not defined.");
    return AFTER_WRAPPER;
}
@callee.rtype@ AFTER_@callee.name@(
    @callee.rtype.change(void=int)@ cppsm_return_value@callee.args.remove(,
    )@@callee.args@)
{
    IF_INSTANCE("default")
    {
        return @callee.rtype.remove(cppsm_return_value)@;
    }
    // NOTICE: instance check is not required normally because
    // - in case when signle chain of wrapper is called, BEFORE has already checked the instance
    // - in case when multiple chain of wrappers are called, the instance have been already changed with last one
    // - however, the checking of the result would be more meaningful if needed
    return @callee.rtype.remove(cppsm_return_value)@;
}
@callee.rtype@ REPLACE_@callee.name@(
    @callee.args@)
{
    // TODO: instances for wrapping
    #if 0
    IF_INSTANCE("E_OK")
    {
        return E_OK;
    }
    #endif
    LOG_SCRIPT_ERROR_EX("Call instance not defined.");
    return @callee.rtype.remove0(0)@; // TODO: change with default error value
}

@end-ncls-once@
#pragma qas cantata ignore off
/* pragma qas cantata testscript end */
/*****************************************************************************/
/* End of test script                                                        */
/*****************************************************************************/
